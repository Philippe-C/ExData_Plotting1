x
class(x)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
x
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
library(datasets)
R(prof)
library(datasets)
Rprof()
fit <- lm(y~x1+x2)
fit <- lm(y ~ x1+x2)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
summaryRprof()
Rprof(lm)
summaryRprof(lm)
brary(datasets)
Rprof()
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
library(datasets)
summaryRprof()
Rprof(lm)
lm
summaryRprof()
# See README.md for instructions on running the code and output from it
# The assignment states that running the code is not part of the grading
# but I have the instructions anyway.
# makeCacheMatrix is a function that returns a list of functions
# Its puspose is to store a martix and a cached value of the inverse of the
# matrix. Contains the following functions:
# * setMatrix      set the value of a matrix
# * getMatrix      get the value of a matrix
# * cacheInverse   get the cahced value (inverse of the matrix)
# * getInverse     get the cahced value (inverse of the matrix)
#
# Notes:
# not sure how the "x = numeric()" part works in the argument list of the
# function, but it seems to be creating a variable "x" that is not reachable
# from the global environment, but is available in the environment of the
# makeCacheMatrix function
makeCacheMatrix <- function(x = numeric()) {
# holds the cached value or NULL if nothing is cached
# initially nothing is cached so set it to NULL
cache <- NULL
# store a matrix
setMatrix <- function(newValue) {
x <<- newValue
# since the matrix is assigned a new value, flush the cache
cache <<- NULL
}
# returns the stored matrix
getMatrix <- function() {
x
}
# cache the given argument
cacheInverse <- function(solve) {
cache <<- solve
}
# get the cached value
getInverse <- function() {
cache
}
# return a list. Each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
# The following function calculates the inverse of a "special" matrix created with
# makeCacheMatrix
cacheSolve <- function(y, ...) {
# get the cached value
inverse <- y$getInverse()
# if a cached value exists return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# otherwise get the matrix, caclulate the inverse and store it in
# the cache
data <- y$getMatrix()
inverse <- solve(data)
y$cacheInverse(inverse)
# return the inverse
inverse
}
a <- makeCacheMatrix( matrix(c(1,2,12,13), nrow = 2, ncol = 2) )
summary(a)
str(a)
a$getMatrix()
cacheSolve(a)
cacheSolve(a)
a <- makeCacheMatrix( matrix(c(1,1,1,1), nrow = 2, ncol = 2) )
a
a <- makeCacheMatrix( matrix(c(1,1,1,1), nrow = 2, ncol = 2) )
a
################################## REMARKS ############################################
# Output from the code are presented in README.md (even if not asked for this assignment!)
# Because it makes the code easier to understand
# From a mathematical perspective, the simpliest squared matrix is of order 2 (2rows and 2 columns)
# If this matrix is given by: A=(a b ; c d) then the inverse A^(-1)=1/DET(A) * (d -b; -c a)
# with DET(A)= a*d - b*c
# For more details (and going beyond order 2), have a look at:
# http://www.mathwords.com/i/inverse_of_a_matrix.htm
# BUT in this assignment we consider the matrix as being always inversible!
############################# FIRST FUNCTION #####################################
# makeCacheMatrix function returns a list of functions
# It allows to store a numeric matrix and a cached value of the inverse of the matrix
# It includes the following functions:
# * setMatrix      set the value of a matrix
# * getMatrix      get the value of a matrix
# * cacheInverse   get the cached value (inverse of the matrix)
# * getInverse     get the cached value (inverse of the matrix)
# makeCacheMatrix function
makeCacheMatrix <- function(x = numeric()) {
# contains the cached value or NULL if nothing is cached
# So we set it initially to NULL
cache <- NULL
#  Matrix storage
setMatrix <- function(newValue) {
x <<- newValue
# The matrix is assigned a new value so we flush the cache
cache <<- NULL
}
# Shows the stored matrix
getMatrix <- function() {
x
}
# Cache the inverse matrix computed thanks to R function solve
cacheInverse <- function(solve) {
cache <<- solve
}
# Get the cached value
getInverse <- function() {
cache
}
# Returns a list. Note that each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
#################################  SECOND FUNCTION #######################################
# The function below computes the inverse of the matrix created with makeCacheMatrix
cacheSolve <- function(y, ...) {
# Get the cached value
inverse <- y$getInverse()
# In case a cached value exists -> return it
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# Otherwise get the matrix, computes the inverse matrix and save it in the cache!
matrix <- y$getMatrix()
inverse <- solve(matrix)
y$cacheInverse(inverse)
# Finally the inverse matrix is returned
inverse
}
a <- makeCacheMatrix( matrix(c(1,1,1,1), nrow = 2, ncol = 2) )
a
summary(a)
a$getMatrix()
cacheSolve(a)
a <- makeCacheMatrix( matrix(c(1,2,3,4), nrow = 2, ncol = 2) )
summary(a)
a$getMatrix()
cacheSolve(a)
cacheSolve(a)
A <
Q
A <-makeCacheMatrix( matrix(c(1,2,3,4), nrow = 2, ncol = 2) )
################################## REMARKS ############################################
# Output from the code are presented in README.md (even if not asked for this assignment!)
# Because it makes the code easier to understand
# From a mathematical perspective, the simpliest squareX>_ matrix is of order 2 (2 rows and 2 columns)
# If this matrix is given by: A=(a b ; c d) then the inverse A^(-1)=1/DET(A) * (d -b; -c a)
# With DET(A)= a*d - b*c, DET(A) must be different of zero!
# So a matrix (1 1; 1 1) will create an error! don't try such a matrix with this specific code...
# For more details (and going beyond order 2), have a look at:
# http://www.mathwords.com/i/inverse_of_a_matrix.htm
# BUT in this Coursera assignment we assume the matrix as being always inversible!
############################# FIRST FUNCTION #####################################
# makeCacheMatrix function returns a list of functions
# It allows to store a numeric matrix and a cached value of the inverse of the matrix
# It includes the following functions:
# * setMatrix      set the value of a matrix
# * getMatrix      get the value of a matrix
# * cacheInverse   get the cached value (inverse of the matrix)
# * getInverse     get the cached value (inverse of the matrix)
# makeCacheMatrix function
makeCacheMatrix <- function(x = numeric()) {
# contains the cached value or NULL if nothing is cached
# So we set it initially to NULL
cache <- NULL
#  Matrix storage
setMatrix <- function(newValue) {
x <<- newValue
# The matrix is assigned a new value so we flush the cache
cache <<- NULL
}
# Shows the stored matrix
getMatrix <- function() {
x
}
# Cache the inverse matrix computed thanks to R function solve
cacheInverse <- function(solve) {
cache <<- solve
}
# Get the cached value
getInverse <- function() {
cache
}
# Returns a list. Note that each named element of the list is a function
list(setMatrix = setMatrix, getMatrix = getMatrix, cacheInverse = cacheInverse, getInverse = getInverse)
}
#################################  SECOND FUNCTION #######################################
# The function below computes the inverse of the matrix created with makeCacheMatrix
cacheSolve <- function(y, ...) {
# Get the cached value
inverse <- y$getInverse()
# In case a cached value exists -> return it!
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
# Otherwise get the matrix, computes the inverse matrix and save it in the cache!
matrix <- y$getMatrix()
inverse <- solve(matrix)
y$cacheInverse(inverse)
# Finally the inverse matrix is returned
inverse
}
A <-makeCacheMatrix( matrix(c(1,2,3,4), nrow = 2, ncol = 2) )
summary(A)
a$getMatrix()
A$getMatrix()
cacheSolve(A)
cacheSolve(A)
setwd("/Users/Philio")
getwd()
list.files()
if(!file.exists("data")) {
dir.create("data")
}
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FDATA.gov_NGAP.xlsx"
download.file(fileUrl, destfile="./data/nga.xlsx", method="curl")
dateDownloaded <- date()
library(xlsx)
list.files("./data")
colIndex <- 7:15
rowIndex <- 18:23
dat <- read.xlsx("./data/nga.xlsx", sheetIndex=1, header=TRUE, colIndex=colIndex, rowIndex=rowIndex)
head(dat)
sum(dat$Zip*dat$Ext,na.rm=T) # 36534720
fileUrl <- "http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(fileUrl, useInternal=TRUE)
doc
rootNode <- xmlRoot(doc)
rootNode
xmlName(rootNode)
names(rootNode)
sum(xpathSApply(rootNode, "//zipcode", xmlValue)==21231) # 127
install.package("XML")
install.packages("XML")
setwd("/Users/Philio")
getwd()
list.files()
if(!file.exists("data")) {
dir.create("data")
}
fileUrl <- "http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(fileUrl, useInternal=TRUE)
doc
rootNode <- xmlRoot(doc)
rootNode
xmlName(rootNode)
names(rootNode)
sum(xpathSApply(rootNode, "//zipcode", xmlValue)==21231) # 127
library(XML)
fileUrl <- "http://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Frestaurants.xml"
doc <- xmlTreeParse(fileUrl, useInternal=TRUE)
doc
rootNode <- xmlRoot(doc)
rootNode
xmlName(rootNode)
names(rootNode)
sum(xpathSApply(rootNode, "//zipcode", xmlValue)==21231) # 127
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv"
download.file(fileUrl, destfile="./data/microdata3.csv", method="curl")
DT <- fread("./data/microdata3.csv")
file.info("./data/microdata3.csv")$size
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(mean(DT[DT$SEX==1,]$pwgtp15))+system.time(mean(DT[DT$SEX==2,]$pwgtp15))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(rowMeans(DT)[DT$SEX==1])+system.time(rowMeans(DT)[DT$SEX==2]
)
#A
st = proc.time()
for (i in 1:100){
sapply(split(DT$pwgtp15,DT$SEX),mean)
}
print (proc.time() - st)
install.packages("data.table")
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv"
download.file(fileUrl, destfile="./data/microdata3.csv", method="curl")
DT <- fread("./data/microdata3.csv")
file.info("./data/microdata3.csv")$size
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(mean(DT[DT$SEX==1,]$pwgtp15))+system.time(mean(DT[DT$SEX==2,]$pwgtp15))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(rowMeans(DT)[DT$SEX==1])+system.time(rowMeans(DT)[DT$SEX==2]
)
#A
st = proc.time()
for (i in 1:100){
sapply(split(DT$pwgtp15,DT$SEX),mean)
}
print (proc.time() - st)
DT <- fread("./data/microdata3.csv")
library(data.table)
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv"
download.file(fileUrl, destfile="./data/microdata3.csv", method="curl")
DT <- fread("./data/microdata3.csv")
file.info("./data/microdata3.csv")$size
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(mean(DT[DT$SEX==1,]$pwgtp15))+system.time(mean(DT[DT$SEX==2,]$pwgtp15))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(rowMeans(DT)[DT$SEX==1])+system.time(rowMeans(DT)[DT$SEX==2]
)
#A
st = proc.time()
for (i in 1:100){
sapply(split(DT$pwgtp15,DT$SEX),mean)
}
print (proc.time() - st)
st = proc.time()
for (i in 1:100){
rowMeans(DT)[DT$SEX==1];rowMeans(DT)[DT$SEX==2]
}
print (proc.time() - st)
st = proc.time()
for (i in 1:100){
mean(DT$pwgtp15,by=DT$SEX)
}
print (proc.time() - st)
#D
st = proc.time()
for (i in 1:100){
tapply(DT$pwgtp15,DT$SEX,mean)
}
print (proc.time() - st)
#E
st = proc.time()
for (i in 1:100){
mean(DT[DT$SEX==1,]$pwgtp15);mean(DT[DT$SEX==2,]$pwgtp15)
}
print (proc.time() - st)
#F
st = proc.time()
for (i in 1:100){
DT[,mean(pwgtp15),by=SEX]
}
print (proc.time() - st)
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
# Getting and Cleaning Data
# Coursera
# John Hopkins University
# Bastiaan Quast
# bquast@gmail.com
# write the file url and file destination to an object
file.url <- 'https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv'
file.dest <- 'ACS2.csv'
# download from the URL
download.file(file.url, file.dest, method='curl' )
# load the data.table package
library(data.table)
# read the data
DT <- fread('ACS2.csv')
# time the processes
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT[DT$SEX==1,]$pwgtp15); mean(DT[DT$SEX==2,]$pwgtp15))
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(rowMeans(DT)[DT$SEX==1]; rowMeans(DT)[DT$SEX==2])
system.time(mean(DT[DT$SEX==1,]$pwgtp15), mean(DT[DT$SEX==2,]$pwgtp15))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT[DT$SEX==1,]$pwgtp15))
system.time(mean(DT[DT$SEX==2,]$pwgtp15))
library(data.table)
DT
str(DT)
DT$sex
DT$SEX
str(DT$SEX)
DT*PWGTP15
DT$pwgtp15
str(DT$pwgtp15)
STR
str(DT$pwgtp15,by=DT$SEX)
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv"
download.file(fileUrl, destfile="./data/microdata3.csv", method="curl")
DT <- fread("./data/microdata3.csv")
file.info("./data/microdata3.csv")$size
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(mean(DT[DT$SEX==1,]$pwgtp15))+system.time(mean(DT[DT$SEX==2,]$pwgtp15))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(rowMeans(DT)[DT$SEX==1])+system.time(rowMeans(DT)[DT$SEX==2]
system.time(rowMeans(DT)[DT$SEX==1])+system.time(rowMeans(DT)[DT$SEX==2]
system.time(rowMeans(DT)[DT$SEX==1])
write the file url and file destination to an object
file.url <- 'https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv'
file.dest <- 'ACS2.csv'
# download from the URL
download.file(file.url, file.dest, method='curl' )
# load the data.table package
library(data.table)
# read the data
DT <- fread('ACS2.csv')
# time the processes
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT[DT$SEX==1,]$pwgtp15); mean(DT[DT$SEX==2,]$pwgtp15))
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(rowMeans(DT)[DT$SEX==1]; rowMeans(DT)[DT$SEX==2])
q()
file.url <- 'https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pid.csv'
file.dest <- 'ACS2.csv'
# download from the URL
download.file(file.url, file.dest, method='curl' )
# load the data.table package
library(data.table)
# read the data
DT <- fread('ACS2.csv')
# time the processes
system.time(mean(DT$pwgtp15,by=DT$SEX))
system.time(tapply(DT$pwgtp15,DT$SEX,mean))
system.time(sapply(split(DT$pwgtp15,DT$SEX),mean))
system.time(mean(DT[DT$SEX==1,]$pwgtp15); mean(DT[DT$SEX==2,]$pwgtp15))
system.time(DT[,mean(pwgtp15),by=SEX])
system.time(rowMeans(DT)[DT$SEX==1]; rowMeans(DT)[DT$SEX==2])
q()
source("Load_data.R")
### Step 3: Creation of the first plot: an histogram
png(filename = "plot1.png",
width = 480, height = 480,
units = "px", bg = "transparent")
hist(Global_active_power,
col = "red",
main = "Global Active Power",
xlab = "Global Active Power (kilowatts)",
breaks = 12, ylim = c(0, 1200))
#### Step 4: Do not forget to exit the graphic device
dev.off()
# Step 1: Check the presence of the file for loading data
if (!"load_data.R" %in% list.files()) {
setwd("/Users/Philio/ExData_Plotting1")
}
## Step2: Access the data
source("load_data.R")
### Step 3: Creation of the first plot: an histogram
png(filename = "plot1.png",
width = 480, height = 480,
units = "px", bg = "transparent")
hist(Global_active_power,
col = "red",
main = "Global Active Power",
xlab = "Global Active Power (kilowatts)",
breaks = 12, ylim = c(0, 1200))
#### Step 4: Do not forget to exit the graphic device
dev.off()
source("Plot1.R")
source(Plot1.png)
source("Plot1.R")
source("Plot1.R")
source("Plot1.R")
source("Plot1.R")
source("Plot1.R")
source("Plot1.R")
source(Plot2.R)
source("Plot2.R")
source("Plot2.R")
source("plot3.R")
Language=en R
Language=en
q()
